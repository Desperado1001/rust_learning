# Rust 控制流

控制流是编程语言的核心功能，用于控制程序执行的顺序。Rust 提供了多种控制流结构，使代码的逻辑清晰且强大。

## `if` 表达式

Rust 中的 `if` 是一个表达式，这意味着它可以产生值并用于赋值。

```rust
// 基本语法
if 条件 {
    // 条件为真时执行
} else {
    // 条件为假时执行
}

// 作为表达式使用
let value = if condition { true_value } else { false_value };
```

注意事项：
- 条件必须是布尔类型，Rust 不会自动转换非布尔类型（如数字）为布尔值
- 不需要括号，但必须有花括号
- `if` 和 `else` 分支的值类型必须相同

## 循环

Rust 提供三种循环结构：

### 1. `loop`

创建无限循环，除非手动退出（使用 `break`）。

```rust
loop {
    // 重复执行的代码
    if 某条件 {
        break; // 退出循环
    }
}
```

`loop` 的特殊功能：
- 可以通过 `break` 返回值：`break value;`
- 可以使用 `continue` 跳过当前迭代，开始下一次循环
- 适合你不知道循环多少次的情况

### 2. `while`

在每次迭代之前检查条件，条件为真才执行循环体。

```rust
while 条件 {
    // 条件为真时重复执行
}
```

### 3. `for`

最常用于遍历集合，如数组、向量或范围。

```rust
// 遍历数组
for element in array.iter() {
    // 对每个元素执行操作
}

// 遍历范围
for number in 1..5 {    // 遍历 1, 2, 3, 4
    // 对每个数字执行操作
}
```

`for` 循环的优势：
- 安全性：不容易出现索引错误
- 高效：编译器可以优化边界检查
- 简洁：代码更加清晰

## `match` 表达式

`match` 是 Rust 中非常强大的控制流运算符，允许将一个值与一系列模式进行比较，并执行匹配到的模式对应的代码。

```rust
match 值 {
    模式1 => 表达式1,
    模式2 => 表达式2,
    _ => 默认表达式,  // _ 是通配符，匹配任何值
}
```

`match` 的特点：
- 穷尽性：必须覆盖所有可能的值（编译器会检查）
- 模式可以是字面值、变量名、通配符或复杂结构
- 可以使用 `|` 匹配多个模式
- 可以使用 `..=` 匹配范围
- 可以使用 `@` 绑定值
- 是表达式，可以用于赋值

## `if let` 和 `while let`

这是 `match` 的简写形式，适用于只关心一种模式的情况。

```rust
// 如果 some_value 是 Some(3)，则执行代码块
if let Some(3) = some_value {
    println!("匹配到三！");
}

// 等价于
match some_value {
    Some(3) => println!("匹配到三！"),
    _ => (), // 不做任何事
}
```

`while let` 类似，但是在条件匹配时重复执行。

## 控制流中的标签

在嵌套循环中，可以使用标签来指定 `break` 或 `continue` 要作用的循环：

```rust
'outer: loop {
    loop {
        break 'outer; // 跳出外层循环
    }
}
```

## 总结

Rust 的控制流机制融合了传统的条件和循环结构，以及函数式编程语言的模式匹配功能。这使得代码可以非常表达力强，同时保持了安全性和可读性。`match` 表达式尤其是 Rust 的亮点，它比其他语言的 `switch` 语句更强大，是实现复杂逻辑的得力工具。